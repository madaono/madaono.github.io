---
layout: post
title: 从页面生成看移动端优化
description: 手机刷一个小时没电了，这个事怪前端
category: coding
---


##网页的生成
###从输入网址到页面显示
作为一个前端，不仅仅要知道页面怎么做，还要明白页面是怎么走的。从用户输入网址到页面显示出来这个过程，拢共分几步？简略的说有下面几个步骤，因为今天准备重点捋一捋页面的渲染过程，所以其他步骤简略带过。  

* 用户输入url地址，通过DNS服务器进行域名解析得到网站的ip地址，然后向这个ip地址发送一个连接建立的请求，如果服务器接收到请求会返回一个确认，客户端得到确认再次发送确认，连接建立成功。
* 浏览器向服务器发送http请求，如果服务器段返回以301之类的重定向，浏览器根据相应头中的location再次发送请求
* 服务器端接受请求，处理请求生成html代码，返回给浏览器，这时的html页面代码可能是经过压缩的
* 浏览器接收服务器响应结果，如果有压缩则首先进行解压处理，紧接着就是页面解析渲染

大概就是以上几个步骤，其中作为前端来说，最为重要的是页面的解析渲染过程，理解了这个过程，对页面的优化有着很大的指导作用，就拿轮播图来说，之前桌面一直用绝对定位做，当然，没什么问题，但是在移动端，因为元素的left/offsetLeft等属性的每次更新，都会触发页面的重排与重绘，作为用户来说，最大的感觉就是耗电量与流量的增加，这无疑就很恶心了，想着我上班时间刷一会网页，玩了一个小时，手机没电了，这TMD就尴尬了。。。  
查询属性是否会触发重排重绘可以上[csstriggers](https://csstriggers.com/)来进行查询。  
##页面的生成过程
- 文档初次加载时，浏览器主进程会解析HTML文档来构建DOM树，
- 之后根据DOM元素的几何属性构建一棵用于渲染的树。渲染树的每个节点都有大小和边距等属性，类似于盒子模型 
- 由于隐藏元素不需要显示，渲染树中并不包含DOM树中隐藏的元素
- 当渲染树构建完成后，浏览器 就可以将元素放置到正确的位置了，再根据渲染树节点的样式属性绘制出页面

######翻译下就是：
- HTML代码首先会转化为DOM树
- CSS代码转化为CSSOM（Css Object Model）
- DOM与CSSOM生成一颗渲染树，树上有所有节点的视觉信息
- 生成布局(layout)，即渲染树上所有的节点进行平面合成
- 绘制（paint）,在用户屏幕上显示

######详细过程：
- 转化： 浏览器从磁盘或网络读取 HTML 的原始字节，浏览器会将这段原始文件按照相应编码规范进行解码（现在一般为 utf-8）。
- 符号化：根据 W3C 标准转化为对应的符号。
- DOM 构建：HTML 解析器会解析其中的 tag 标签，生成 token ，
（注意：遇到 CSS 或 JS 会发送相应请求。HTML 解析是阻塞主进程的，CSS 一般也是阻塞主进程的，也就是说它们在解析过程中是无法做出响应的。而 JS 手动添加 async 后达到异步加载，根据 token 生成相应 DOM 树。）
- CSSOM 构建，添加 CSS 样式生成 CSSOM 树。
- 渲染树构建，从 DOM 树的根节点开始，遍历每个可见的节点，给每个可见节点找到相应匹配的 CSSOM 规则，并应用这些规则，连带其内容及计算的样式。
- 样式计算，浏览器会将所有的相对位置转换成绝对位置等一系列的样式计算。
- 布局，浏览器将元素进行定位、布局。
- 绘制，绘制元素样式，颜色、背景、大小、边框等。
- 合成，将各层合成到一起、显示在屏幕上

其中有几个注意点：  
1.DOM树的构建是远远快于渲染树的；  
2.dom树与渲染树的构建几乎是同时进行的,只是渲染树的构建基于dom树  
3.网络的模型是同步的。解析器遇到“内联”&lt;script>标记时立即解析并执行脚本这时文档的解析将停止，直到脚本执行完毕。  
4.如果是“外部”的&lt;script>标签，那么整个DOM树的构建、Js解析执行过程都会停止，直到网络同步抓取资源完成后再继续。<b>与此同时,</b>chrome以及Firefox会开启一个分进程来解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。  
5.样式表的问题，样式表有着不同的模型，理论上来说，应用样式表不会更改 DOM 树，因此似乎没有必要等待样式表并停止文档解析。但这涉及到一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，脚本就会获得错误的回复，这样显然会产生很多问题。这看上去是一个非典型案例，但事实上非常普遍。Firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于 WebKit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。


###重点是其中的重绘（Repaint）与重排（Reflow）

为什么会发生重绘，当然是有元素的外观发生了改变，例如改background-color,color等属性，来让元素显示新的外观。  
至于重排，渲染对象在创建完成并添加到渲染树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排。  
通过上面的定义不难推出："重绘"不一定需要"重排"，但是，"重排"必然导致"重绘"，比如改变一个网页元素的位置，就会同时触发"重排"和"重绘"，因为布局改变了。还有，不单单是样式的改变会触发重绘重排，我们请求一些style信息时也会让浏览器强行刷新渲染队列，而这也是十分消耗性能的，也是我文章一开头举的例子，我们在获取

	1.offsetTop, offsetLeft, offsetWidth, offsetHeight
	2.scrollTop/Left/Width/Height
	3.clientTop/Left/Width/Height
	4.width,height
	5.getComputedStyle(), 或者 IE的 currentStyle

这些属性时也会大大的消耗性能。  
基于重排的成本要大大大于重绘，所以如何减少重排与重绘无疑是我们在写移动端界面时应该考虑的问题。

###优化的方法
在工作中，我喜欢用以下这几种方法来减少重绘与重排：
  
	1.将多次改变样式属性的操作合并成一次操作
	2.将需要多次重排的元素，position属性设为absolute或fixed，
		这样此元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位。
	3.display属性设置为none（此时此元素不在渲染树中），对隐藏的元素操作不会引发其他元素的重排。
		就比如要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次重排。
 
恩，大概就是这样。